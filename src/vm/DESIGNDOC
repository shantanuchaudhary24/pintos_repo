       	    +---------------------------+
		    |          CSL373			|
		    | PROJECT 3: VIRTUAL MEMORY	|
		    |	   DESIGN DOCUMENT		|
		    +---------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

Shantanu Chaudhary <cs5100295@cse.iitd.ernet.in>
Ankur Garg <cs1100208@cse.iitd.ernet.in>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
	Please refer to the svn logs and comments in the source code to get a
	clear idea about the code.Most of the source code is self explanatory
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.
	Book-Operating System Concepts
	LINUX Programmers Manual
	http://en.wikipedia.org/wiki/Virtual_address_space
	http://en.wikipedia.org/wiki/Virtual_memory

			PAGE TABLE MANAGEMENT
			=====================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

Following struct has been added to the supplementary page table:
struct supptable_page
{
	/* For Hashing */
	struct hash_elem hash_index;

	/* Data to be fed into the supplementary page table*/
	int page_type;
	struct file *file;
	off_t offset;
	void *uvaddr;
	uint32_t read_bytes;
	uint32_t zero_bytes;
	bool writable;
	bool is_page_loaded;	

	/* For Swapping purpose*/
	size_t swap_slot_id;
	bool swap_writable;
};

This structure describes an entry in a supplementary page table.This structure follows its content from the lazy_load_segment() function in process.c:line 521.It saves a hash_elem type hash_index which is used to maintain entries in the hash table datastructure of the supplementary page table.Other contents are the file,offset,uvaddr(user virtual address it is to be mapped with) corresponding read_bytes,zero_bytes, writable(to tell if the page entry to be mapped is writable or not),is_page_loaded in swap/file,swap_slot_id(to identify the swap slot it belongs to if any),swap_writable(if it is to be read-only).


struct thread 
{
…
struct hash suppl_page_table;
…
}
A struct hash suppl_page_table in the struct thread represents the per process shadow page table.

>>>>>>>>>>>> For Swap Space Management <<<<<<<<<<<<
Our implementation uses a global swap space struct.This struct is protected by a lock.
struct struct_swap
{
	struct block *swap_disk;
	struct bitmap *swap_table;
};
Above structure defines the fields that are used to manage the swap space. The struct consists of a pointer to a swap disk(represented by struct block) and a pointer to a swap table(represented by a bitmap data structure).

static struct lock swap_lock;
This lock is used to manage the access to swap space device and swap table.


---- ALGORITHMS ----

>> A2: In a few paragraphs, describe your code for locating the frame,
>> if any, that contains the data of a given page.

>> A3: How does your code coordinate accessed and dirty bits between
>> kernel and user virtual addresses that alias a single frame, or
>> alternatively how do you avoid the issue?
We haven't implemented sharing of frames. So, this problem doesn't arise.
But if this would have been the case then copy on write would be the solution.

---- SYNCHRONIZATION ----

>> A4: When two user processes both need a new frame at the same time,
>> how are races avoided?
While allocating a new frame, first we do palloc_get_page(). Palloc itself
uses lock for allocating frames. Now, it returns null, we evict already mapped
frame. Before doing this, we acquire lock. So two processes won't interfere
with other's frame allocation.

---- RATIONALE ----

>> A5: Why did you choose the data structure(s) that you did for
>> representing virtual-to-physical mappings?
We used list for implementing frameTable, because list's implementation
is easier.

		       PAGING TO AND FROM DISK
		       =======================

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

The following struct has been added to implement the frame Table. Each entry in the frame Table is an instance of this struct.
struct frameStruct {
	void *frame;
	tid_t tid;
	void *page;
	struct list_elem listElement;
};

The following is a list used to maintain records of the frame alloted.
struct list frameTable;

The struct frameStruct contains following elements:
frame is used to store the frame which this entry refers to.
tid is used to store the thread to which this entry belongs.
page is the virtual address in the pagedir of the thread which is mapped to this frame
and finally listElement of the type list_elem which is used to maintain the entries in the list

---- ALGORITHMS ----

>> B2: When a frame is required but none is free, some frame must be
>> evicted.  Describe your code for choosing a frame to evict.

We have implemented the clock algorithm for finding out the frame to evict.

When a frame is needed but no frame is free, then we traverse the frame 
Table list starting from a global static pointer (position of last evicted
frame), and traverse the whole list to find a page which has been marked
as not accessed. If on our way, we find any pages which are accessed, we mark
them as not accessed. when we find a frame table entry, we change its 
contents. Whenever we have to insert a new frame table entry into the table,
we insert it just before this pointer. Whenever we have to evict a frame
entry, we start from this pointer. This pointer basically marks as a starting
and ending of the list.


>> B3: When a process P obtains a frame that was previously used by a
>> process Q, how do you adjust the page table (and any other data
>> structures) to reflect the frame Q no longer has?

When a frame previously being used by Q is chosen to be evicted, we know that
it belonged to Q using the tid stored in the frameStruct and also we know the
virtual address it is mapped to in the process Q's pagedir (using the page
stored in frameStruct). So, we use pagedir_clear_page() to remove the mapping of 
this virtual address from the process Q's page directory so that Q no longer
has a reference to this frame. Then this frame can be used by the process P.


>> B4: Explain your heuristic for deciding whether a page fault for an
>> invalid virtual address should cause the stack to be extended into
>> the page that faulted.
There are two cases:
>If the fault was due to user segment then we check if the access was a
write and the fault address satisfies two conditions:
	>> It lies in the address range esp-32bytes.
	>> It also lies within the bounds of stack size.

>If the fault was due to the kernel segment then we check if the access
was a write and the fault address lies in the address range t->stack-32
Here t->stack is the saved stack pointer in the struct thread.This is 
set in the syscall_handler function.	


---- SYNCHRONIZATION ----

>> B5: Explain the basics of your VM synchronization design.  In
>> particular, explain how it prevents deadlock.  (Refer to the
>> textbook for an explanation of the necessary conditions for
>> deadlock.)
We have made sure that we acquire locks such that there is no deadlock.
We have tries to use locks such that two processes don't acquire different
locks and keep asking for each other's lock. We tried to keep the critical
sections as small as possible.


>> B6: A page fault in process P can cause another process Q's frame
>> to be evicted.  How do you ensure that Q cannot access or modify
>> the page during the eviction process?  How do you avoid a race
>> between P evicting Q's frame and Q faulting the page back in?
When we are evicting a frame, we remove its entry from the supplememtary
page table. While doing so we acquire a lock on the supplementary page table,
so that no other thread can access it. So, other thread whose supplememtary page
table is being modified, won't be able to access its supplementary page table
until someone else is done changing it.

>> B7: Suppose a page fault in process P causes a page to be read from
>> the file system or swap.  How do you ensure that a second process Q
>> cannot interfere by e.g. attempting to evict the frame while it is
>> still being read in?

The locks which we have used on the frame table and swap ensure this
atomicity. At a time only one process can access and modify the frame
table or the swap table(whichever it needs to access/modify).Also we
have a supplementary page table lock which checks the atomicity of access
to supplementary table of a process, if it is altered by any other process.
(Example in case of eviction.)

>> B8: Explain how you handle access to paged-out pages that occur
>> during system calls.  Do you use page faults to bring in pages (as
>> in user programs), or do you have a mechanism for "locking" frames
>> into physical memory, or do you use some other design?  How do you
>> gracefully handle attempted accesses to invalid virtual addresses?

We handle the access to paged out pages that occur during system calls
using page faults.In the page_fault we have the code for fetching the
page by consulting the supplementary page table.So when there is an
invalid access and a page fault occurs, we identify the type of fault.
If the fault was due to a system call then we would land in the KCSEG 
part of the fault and from there we can demand page the address at which
fault occured.

---- RATIONALE ----

>> B9: A single lock for the whole VM system would make
>> synchronization easy, but limit parallelism.  On the other hand,
>> using many locks complicates synchronization and raises the
>> possibility for deadlock but allows for high parallelism.  Explain
>> where your design falls along this continuum and why you chose to
>> design it this way.

A single lock for the whole VM system would definitely limit parallelism.
As stated above, we have used an internal lock for frame table, swap table.
And since the supplementary page table is per process, it doesn't need a lock.
Supplementary page table would be immune to context switch. On the other hand,
there may be processes which want to access the swap table, frame table. And so
here we need a lock to check their access.

			 MEMORY MAPPED FILES
			 ===================

---- DATA STRUCTURES ----

>> C1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

The following structure is used for the memory mapped files.
struct mmfStruct {
	mapid_t mapid;
	struct file *file;
	void * begin_addr;
	unsigned pageCount;
	struct hash_elem Element;
};

This structure contains mapid which denotes the is of each mapping
file: the corresponding opened file which this mapping corresponds to.
begin_addr: the address at which the mapping begins
pageCount: the number of pages which are used in the mapping of this file
Element: hash_elem used to maintain the hash index in the mmfiles hash table below.

Following changes are made to the thread struct in the thread.h corresponding to the 
mmfiles.
struct thread {
…
struct hash mmfiles;
mapid_t mapid_allocator;
…
}
struct hash mmfiles: This is the per thread hash table for maintaing
the memory mapped files corresponding to each thread. Each entry in this
hash table corresponds to one mapping
mapid_allocator: this is used to store the max mapid used so far. It is
used to allocate a new id to the mapping of that thread.

---- ALGORITHMS ----

>> C2: Describe how memory mapped files integrate into your virtual
>> memory subsystem.  Explain how the page fault and eviction
>> processes differ between swap pages and other pages.

As explained above, a hash table is maintained in each process to maintain 
the memory mapped files of that process. When a process begins, the hash
table is initialised. Files are mapped and unmapped using the mmap and unmap
system calls which are handled in the syscall_handler(). mmap loads an opened
file into the memory, allotes a new mapid to it and created a corresponding 
entry in the mmfiles hash table. munmap frees the memory corresponding to the
mapping. If the corresponding pages are dirty, the page contents are written
back to the file, othewise it directly frees the pages. Whenever a process
exits, all the mapping in the hash table mmfiles are removed.

>> C3: Explain how you determine whether a new file mapping overlaps
>> any existing segment.

Before the mmfiles_insert function is called (for mapping the file), we 
calculate the number of pages required to map the given file using the 
file_length(). Starting from the begin_addr, we check all the pages upto 
(n-1)*PGSIZE + being_addr. If any of them is already mapped to any frame
then we return -1. The pages are checked in both the supplemental page 
table as well as the pagedir of the process. If it is present in any of 
the tables, we return -1.

---- RATIONALE ----

>> C4: Mappings created with "mmap" have similar semantics to those of
>> data demand-paged from executables, except that "mmap" mappings are
>> written back to their original files, not to swap.  This implies
>> that much of their implementation can be shared.  Explain why your
>> implementation either does or does not share much of the code for
>> the two situations.

Both the mappings: the ones created by the mmap and the ones created for
the executables have similar seamtics. That's why we have used the same
data structure to represent both the mappings. Both the mapping are stored
in the supplementary page table. Since both are using the same data structure
and same hash table, we have tried to make them share the code as much as
possible. For e.g. the function supptable_add_file(...) is common to both
mappings. We just included one more parameter to distinguish between the
mappings. This parameter is page_type. This is stored in the suppl_page_table
to distinguish between the mappings.

			   SURVEY QUESTIONS
			   ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the course evaluations at the end of
the quarter.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?
